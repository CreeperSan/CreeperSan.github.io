---
layout:     post
title:      "关于JAVA的字符串和正则表达式"
date:       2017-06-10 17:00:00
author:     "CreeperSan"
header-img: "img/post/170610string/header.jpg"
tags:
    - JAVA
    - String
    - 正则表达式
---

## 字符串

---
### 值得注意的一些事情
+ 字符串是不可变的。每当我们对字符串进行操作的时候其实是创建了一个新的字符串对象。
+ 当我们使用+号连接字符还时，反编译代码可以看出实际上是编译器自动引入了String Builder类，并调用了其appedn()方法来连接字符串。因为他更高效。
+ 尽管编译器会自动使用String Builder以优化性能，但是我们还是尽量使用String Builder，以减少编译器生成的String Builder的数量。详细说明见《Jaca编程思想》第四版P285-286
+ 遍历Collection时注意this与toStrin()的使用，以防造成无意识的递归。P287例子

---

### 格式化输出

> Java SE5推出
> 使用例子：System.out.formai("Row1[%d %f],10,20.5");
> 输出：Row1[10 20.5]

+ System.out.format()与System.out.printf()是等价的
+ 格式化说明符的抽象语法 : %(argument_index$)(flags)(width)(.precision)conversion可以用-来改变对齐方式，详见P291
	+ System.out.format("%-15s %5s %10s","Item","Qty","Price");则输入如下
	+ Item             Qty     Price(此处显示格式有问题，详见P291)
+ Format类型字符转换
	+ d 整数型（十进制）
	+ c Unicode字符
	+ b Boolean字符(注意！null为false，非空（包括0）为true)
	+ s String
	+ f 浮点数（十进制）
	+ e 浮点数（科学计算）
	+ x 整数（十六进制）
	+ h 散列码（十六进制）
	+ % 百分号字符'%'
+ 可以使用String.format()方法，传入同样的参数，可以返回格式化后的String字符串（其实其内部也是创建一个Format对象，不过这可以让代码更易读）

---

### 正则表达式
> 正则表达式是一种强大而灵活的文本处理工具。使用正则表达式我们可以编程的形式构造复杂的文本模式，并对输入的字符串进行搜索。一旦查找到了匹配这些模式的部分，就能够随心所欲的对他们进行处理。

+ string.match("正则表达式");返回值为所指定的字符串是否匹配此正则表达式
+ string.spill()传进去一个正则表达式，与正则表达式相匹配的部分会直接被删除掉。
+ 基础
	+ \- 符号
	+ ? 问号前面的一块内容可能存在(没有或者有一个)
	+ \+ 一个或多个
	+ \* 没有或多个
	+ \d 一位阿拉伯数组
	+ \\\\ 我要插入一个正则表达式的反斜线，所以其后的字符具有特殊的意义，注意在其他语言中 \\\\ 表示我想要在正则表达式中插入一个字面意义上的反斜线，它没有特殊意义。~~个人理解就是JAVA的两条反斜杠抵其他语言的一条反斜杠~~
	+ \\\\\\\\ 插入一条普通的反斜杠
	+ \\\\d 表示有以为数字
	+ \\\\d+  表示有一位或者多位数字
	+ | 表示或操作
	+ ()表示将正则表达式分组 ~~个人理解就跟运算符的括号差不多一个意思~~
	+ \\W 表示非单词字符
	+ \\w 表示一个单词字符
+ 创建正则表达式
	> #### 字符
	> B 表示指定字符B
	> \xhh 表示十六进制值为0xhh的字符
	> \uhhhh 表示十六进制表示为0xhhhh的字符
	> \t 表示制表符Tab
	> \n 表示换行符~~($好像也是)~~
	> \r 表示回车
	> \f 表示换页
	> \e 表示转义(Escape)
	> #### 字符类
	> · 表示任意字符
	> [abc] 表示包含了a或者b或者c的任何字符，相当于a|b|c
	> [^abc] 表示除了a，b，c之外的任何字符
	> [a-zA-Z] 表示a到z或者A到Z的任何字符
	> \s 表示空白符（空格，tab，换行和回车）
	> \S 表示非空白符
	> \d 表示阿拉伯数字[0-9]
	> \D 表示非阿拉伯数字[^0-9]
	> \w 表示词字符[0-9a-zA-Z]
	> \W 表示非词字符[^\w]
	> #### 逻辑操作符
	> XY 表示Y跟在X后面
	> X|Y 表示X或者Y
	> (X) 捕获组
	> #### 边界适配符
	> ^ 表示一行的开始
	> $ 表示一行的结束
	> \b 表示词的边界
	> \B 表示非词的边界
	> \G 表示前一个匹配的结束
	> #### 数量适配符
	> ? 表示出现一次或者不出现
	> * 表示出现任意次
	> + 表示出现一次或者多次
	> {n} 表示正好出现n次
	> {n,}表示出现n次以上
	> {n,m}表示出现n-m次
	> #### 量词
	> > 量词一般用于秒速和匹配次数(*,+,?,{n,m})的后面，在其后加?表示为懒惰匹配，勉强型。在其后加+表示其为占有型，什么都不加则表示为贪婪型。
	> + 贪婪型 : 量词本身就是贪婪的。贪婪表达式会为所有可能的模式发现尽可能多的匹配。导致此问题的的一个典型理由就是假定我们的模式仅能匹配第一个可能的字符串，如果他是贪婪的，那么他就会一直往下匹配。贪心的量词会首先匹配整个字符串。尝试匹配的时候，他会选定尽可能多的内容，也就是整个输入。量词首先尝试匹配整个字符串，如果失败则回退一个字符后再次尝试。这个过程我们称之为回溯。他会每次回退一个字符，直到找到匹配的内容或者没有字符可尝试为止。此外它还记录所有的行为，因此相比其他两种方式，它对资源的消耗最大。它先吃掉所有的字符，然后每次吐出来一点，慢慢咀嚼消化。
	> + 勉强型 : 用问号来指定，这个量词的匹配满足模式所需求的最少字符数。因此也称作懒惰的、最少匹配的、非贪婪的、或不贪婪的。他从目标的起始位置开始尝试地寻找匹配，每次检查字符串的一个字符，寻找他匹配的内容。最后他会尝试匹配整个字符串。要是一个两次成为懒惰的，必须在起后面加一个问号（?）。它每次吃一点。
	> + 占有型 : 目前，这种类型只有在JAVA语言中才能用（在其他语言不可用），并且也更高级。当正则表达式在应用于字符串的时候，他会产生相当多的状态，以便在匹配失败的时候可以回溯。而“占有型”的量词并不保存这些中间状态，因此他们可以防止回溯。他们常常用于防止正则表达式失控，因此可以让正则表达式执行起来更有效率。
	> <table><tr><td>贪婪型</td><td>勉强型</td><td>占有型</td><td>匹配方式</td></tr>
	<tr><td>X?</td><td>X??</td><td>X?+</td><td>一个或者没有X</td></tr>
	<tr><td>X*</td><td>X*?</td><td>X*+</td><td>没有或者多个X</td></tr>
	<tr><td>X+</td><td>X+?</td><td>X++</td><td>一个或者多个X</td></tr>
	<tr><td>X{n}</td><td>X{n}?</td><td>X{n}+</td><td>恰好n次X</td></tr>
	<tr><td>X{n,}</td><td>X{n,}?</td><td>X{n,}+</td><td>至少n次X</td></tr>
	<tr><td>X{n,m}</td><td>X{n,m}?</td><td>X{n,m}+</td><td>X至少n次且不超过m次</td></tr></table>

+ Pattern和Matcher
	首先用static Pattern.compile()方法来编译你的正则表达式。它会根据你的String类型的正则表达式生成一个Pattern对象。接下来把想要检索的字符串对象传入Pattern对象的matcher()方法里面。此方法将会返回一个Matcher对象。其有很多功能可以用。
    Pattern对象表示编译后的正则表达式。静态方法boolean matches(String regex,CharSequence input)用于检查正则表达式是否匹配整个input参数。其split()方法用于分割输入字符串，返回分割后的子字符串String数组。
    + 组 ： 组是用括号划分的正则表达式。其本身是组0，第一个括号为组1，以此类推。如A(B(C))D，其中组0是ABCD,组1是BC，组2是B
    + 一些方法
    	> matches 用来匹配整个字符串，整个字符串符合正则表达式，才返回true.
    	> find 用来匹配部分字符串， 整个字符串中有部分子串符合正则表达式，返回true.
    	> lookingAt 用来检测字符串的开头部分是否符合正则表达式，如果符合，返回true.
    	> group 用来获取匹配到的字符串。
    	> start 获取匹配子串（或整个字符串）的起始位置。 只有在匹配成功时才能调用。
    	> end 获取匹配子串的 结束位置（匹配到的最后一个字符位置+1）。 只有在匹配成功时才能调用。
    + 编译标记
    	Pattern()方法的第二个参数，可选。用于设置编译正则表达式的编译标记。可以通过|组合多个标记。
    	+ Pattern.CANON_EQ : 两个字符当且晋档他们的完全规范分解相匹配时，就认为他们是匹配的。例如我们指定了这个标记，表达式a\u030A就会匹配到字符串?。在默认情况下，匹配不考虑规范的等价性。
    	+ Pattern.CASE_INSENSITIVE(?i)默认情况下，大小写不敏感的匹配假定只有US-ASCII字符集中的字符才能进行。这个标记设置了模式对大小写不敏感。如果结合UNICODE_CASE则可以基于Unicode的大小写不敏感。
    	+ Pattern.COMMENTS 忽略空格，并且已#开始到行末的注释也会被忽略。
    	+ Pattern.DOTALL 表达式.将匹配所有字符，包括行终结符（默认是不匹配的）。
    	+ Pattern.MULTILINE 在多行模式下，^， $将增加匹配到一行的开始与结尾，默认情况下是不行的。
    	+ Pattern.UNICODE_CASE 让大小写不敏感匹配按照Unicode标准进行匹配
    	+ UNIX_LINES 在这种模式下，. ^ &行为中，只能识别行终结符\n
    + Matcher的reset方法可以重新设置字符串来匹配结果。如果不写参数，则重新设置到当前序列的起始位置。

+ 例子
	+ > -?\\\\d+
	  > 表示可能有一个负号，后面跟着一位或者多位数字
	+ > (-|\\\\+)?\\\\d+
	  > 表示起始字符是-或者+或者两个都没有(因为有个?)，然后后面跟着一个或者多个数字（因为+在正则表达式中有特殊意义，所以用了\\\\+）

+ String Tokenizer
	在引入正则表达式之前的分割字符串方法，就不做提及了.

