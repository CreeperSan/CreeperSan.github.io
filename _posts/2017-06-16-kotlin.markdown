---
layout:     post
title:      "Kotlin记录"
date:       2017-06-16 23:16:00
author:     "CreeperSan"
header-img: "img/post/170507about/header.jpg"
tags:
    - Kotlin
    - 入门
---

## Kotlin

### 变量
变量后面加一个?，表示此变量是Nullable
变量后面加!!，表示即使为空都要执行这个方法
对象后面加?.方法()，表示如果为空则不执行这个方法

+ if空，执行语句
	val data = ...
	val email = data["email"] ?: throw IllegalStateException("Email is missing!")

### 数据类型
+ Boolean布尔值，同java的boolean与Boolean，由编译器决定是装箱类型还是基本类型，不需要我们去关心
+ Number类型
	+ 整形
		+ Long(64)
		+ Int(32)
		+ Short(16)
	+ 浮点数
		+ Float(32)
		+ Double(64)
	+ 字节
		+ Byte(8)
	+ Tips
		+ 定义变量的时候Kotlin支持16进制与2进制
		+ 写数字的时候E代表10的E后面的数字次方
		+ Float类里面有一个常量NaN(Not a Number)它与0/0的出来的结果并不相等，皆因它不是一个数，比较起来没有意义
		+ 浮点类型的最小值表示的是最小的非0正数
+ Char类型
	+ 字符对应JAVA的Character类型
	+ 占2个字节，表示一个16为的Unicode字符
	+ 字符用单引号引起来，例如'a','b','\n'
+ String类型
	+ 对于String类型的比较需要注意 == 与 =\== 的区别
	+ ==用于比较字符串的内容，用=\==用于比较字符串的对象是否相同
	+ $符号可以直接把变量写在其后面自动连接成字符串，不仅仅支持变量，Kotlin还支持表达式，表达式需要用{}包围住
	+ 使用3个双引号包含起来的字符串成为原始字符串，可以在里面直接换行，缩进，空格而不用去打转义字符。
	+ 构造的时候也可以传入一个charArray数组
+ 转义字符
	+ \t 制表符
	+ \b 光标后退一个字符
	+ \n 回车
	+ \r 光标回到行首
	+ \' 单引号
	+ \" 双引号
	+ \\\\ 反斜杠
	+ \\$ 美元符号，Kotlin支持美元符号开头的字符串模板
+ Tips
	+ 打个比方，再java中，int是基本类型，Integer是装箱类型。但是再Kotlin中并没有做如此的区分,Kotlin编译器会自动进行转换
	+ \u表示的就是一个Unicode，一个标准的Unicode格式可以是这样子 '\u000f'

### 基本类型转换
+ 不可隐式转换
	+ ```Kotlin
	  val anInt:Int = 5
      val aLong:Long = anInt.toLong()  //这里的toLong必要要，编译器不会隐式的把anInt转换成Long类型
	  ```

### 类
+ 使用关键字class创建
+ constructor为其构造方法
+ init为类创建时调用的方法，可以被继承
+ class默认是final的，是不可被继承的，假如我们要继承自这个类，那么我们就需要添加 open 关键字
+ 继承的关键字是 :
+ Kotlin所有的类都直接或者间接是Any的子类
+ 对象 is 类,is关键字有点像JAVA的 instanceof

### 空类型安全与智能类型转换
+ 变量或者类型后面加?则表明其有可能为空。如果没有则不可能为空，当然也不能返回空值。
+ 假如对象a是String?类型则表明他是String类型但也有可能为null
+ 继承上一条的条件,假如a为null，我们这样调用pringln(a?)，假如a为空，则会打印出null,假如a为"A"，则会打印A
+ if(getName()==null)return 可以简写成 getName()?:return
+ a!!.length 表示当编译器提示你a有可能为null时，告诉编译器此对象我了解他不是null，可以直接执行。
+ 假如对象执行过 is 类名并反悔了true，那么接下来的代码就可以直接把对象当作 类名 对象来使用(JAVA不行)。
+ 对于上面这一条，!!.也适用。
+ 类型转换 JAVA使用 (类名)a 而Kotlin使用 a as 类名,?as则代表不成功则返回null（默认不成功就抛异常）

### 包
+ 包其实就是命名空间
+ 包的声明必须在非注释代码的第一行
+ 其实跟java类似

### 区间 (Range)
+ java没有
+ 例子
	+ val mRange:IntRange = 0..1024 //指的是0到1024这个闭区间
	+ val mRange:IntRange = 0 untill 1024 //指的是0到1023这个闭区间。（0到1024的半开区间）
	+ val emptyRange:IntRange = 0..-1 // 将返回一个EmptyRange,其isEmpty() = true
+ .contains()方法与 in 操作符时完全等价的。
+ range可以用于迭代，迭代时也用的 in 操作符

### 数组
+ intArrayOf(Int...) //快速生成一个Int数组，这样写可以减少一些装箱与拆箱的开销
+ charArrayOF(Char...) //快速生成一个Char类型的数组，这样写可以减少一些装箱与拆箱的开销
+ 对于其他没有直接早数组的方法，可以使用泛型,比方说 ```val arrayOfString Array<String> = arrayOf(“你”,"好","吗?")```
+ ```.joinToString('')```可以把char数组给连接起来。并且连接符为空字符
+ ```.slice()```数组的切片
+ slice()也可以用在String中

### 变量
+ Kotlin用const修饰的val为编译器常量，通过阅读他的字节码文件可以看到，在他初始化的时候就直接赋予了值而不是赋予了值的引用。性能上相对会好一点.
+ Kotlin具有类型推导功能，在能确定类型的情况下可以不写变量类型

### 函数
+ 单一原则
+ 在Java里面。，没有返回值就是返回的void,但是在Kotlin里面没有返回值，返回的时Unit,可以不用写，它没有太多含义
+ 如果函数时直接返回简单的运算值。可以直接等于比如下面2点时相等的
	+ ```Kotlin
	fun sum(arg1:Int,arg2:Int):Int{
    	return arg1 + arg2
    }
    ```
    + ```Kotlin
    fun Sum(arg1:Int:arg2:Int) = arg1 + arg2
    ```
+ 匿名函数，这个类似于Python，函数也是一个对象，也可以这样写
	+ ```Kotlin
    val int2Long = fun(x:Int):Long{
    	return x.toLong()
    }
    ```
+ 对于匿名函数的使用，也是类似的，以上免的作为例子，可以写成这样```val longInt = int2Long(5)```
+ 函数的参数个数不要太多，有能能会让虚拟机的执行效率大打折扣

### Lambda表达式
+ 比方说有这么一个匿名函数，这样写```val sum = {arg1:Ibt,arg2:Int -> return arg1 + arg2}```
+ 比方说他没有返回值，那么可以这样写```val printHello = {println("Hello")}```
+ Lambda表达式的返回值不仅仅写一行代码，其实他只是返回最后一行的代码。可以这样子写
	```Kotlin
	val sum = {arg1:Int,arg2:Int ->
    	print("结果为${arg1 + arg2}")
        arg1 + arg2
    }
    ```
+ 对于Lambda表达式的匿名函数的括号()，其实是Koitlin的的运算符重载，它对应invoke()方法
+ 参数名字如果不写，那么其名字默认为 it，迭代器的意思
+ 可以利用Lambda迭代数组，我们可以使用数组的扩展方法forEach()，参数里面穿进去一个lambda表达式，像下面这样子
    ``` Kotlin
    array.forEach({
    	element -> println(element)
    })
    //简化
	array.forEach(){
    	element -> println(element)
    }
    //简化
    array.forEach(){ println(it) }
    //简化
    array.foreach{ println(it) }
    //最简化其实还可以简化成下面这样
    array.forEach(::println)
    ```
+ 注意，迭代时lambda表达式它本身并不是一个作用域，它执行的函数就是在他所在的作用于里面执行的。假如在Lambda表达式里面执行了return语句，那么他自身以及所在的函数就会退出。如果要让Lambda表达式具有自己的作用域，那么我们可以增加一个这样的标签，可以写成这样子
	```Kotlin
    array.forEach ForEach@{
    	if(it == "q") return@ForEach
        println(it)
    }
    ```
+ Lambda表达式的类型，比如上面的sum函数，他的参数类型折这样的```(Int,Int) -> Int```，假如他不用传参数，并且返回值为空，那么他的阐述类型是这样的```() -> Unit```
+ 其实向lambda表达式是有名字的，他被定义在了Function.interface里面，名字为Function0到Function22
+ 当我们把一个剧名函数作为变量传入到一个函数里面的时候，要在具名函数的前面加2个:，表示对函数的引用，例子```println(::println)```
+ 如果参数超过了22个，则会在运行时抛出ClassNotFound异常，但是在编译的时候不会报错。~~~ 难道用的是反射？ ~~~

### 重要
+ Kotlin里面 == 与.equals()这两个方法是等价的。
+ 如果想比较2个对象是否表示同一个对象，则应该用 =\== ，他表示对象的引用值。类似于Java的 ==